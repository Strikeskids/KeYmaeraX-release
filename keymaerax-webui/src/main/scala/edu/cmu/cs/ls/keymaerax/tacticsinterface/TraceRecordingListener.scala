package edu.cmu.cs.ls.keymaerax.tacticsinterface

import edu.cmu.cs.ls.keymaerax.bellerophon._
import edu.cmu.cs.ls.keymaerax.pt.ProvableSig
import edu.cmu.cs.ls.keymaerax.hydra.{ProofPOJO, ExecutionStepPOJO, DBAbstraction, ExecutionStepStatus}
import edu.cmu.cs.ls.keymaerax.hydra.ExecutionStepStatus.ExecutionStepStatus

/**
  * Created by bbohrer on 11/20/15.
  */

/**
  * @param ruleName A display name merely for UI purposes
  */
class TraceRecordingListener(db: DBAbstraction,
                             proofId: Int,
                             initialSibling: Option[Int],
                             globalProvable: ProvableSig,
                             branch: Int,
                             ruleName: String) extends IOListener {

  class TraceNode(isFirstNode: Boolean) {
    var id: Option[Int] = None
    var parent: TraceNode = null
    var sibling: Option[Int] = None
    var local: ProvableSig = null
    var executable: BelleExpr = null
    var status: ExecutionStepStatus = null
    var reverseChildren: List[TraceNode] = Nil

    def children = reverseChildren.reverse

    /* This is generated by the DB, so it will not be present when we first create an object for the step. However,
       we need to set it once it has been generated so other steps can get the appropriate ID.
     */
    var stepId: Option[Int] = None
    val branchLabel: String = null
    val branchOrder: Int = branch
    val userExe = isFirstNode

    var localProvableId: Option[Int] = None
    var executableId: Option[Int] = None

    def getLocalProvableId: Option[Int] = {
      if (local != null && localProvableId.isEmpty)
        localProvableId = Some(db.createProvable(local))
      localProvableId
    }

    def getExecutableId: Int = {
      if (executable != null && executableId.isEmpty)
        executableId = Some(db.addBelleExpr(executable))
      executableId.get
    }

    def asPOJO: ExecutionStepPOJO = {
      //val parentStep = if (parent == null) None else parent.stepId
      ExecutionStepPOJO(stepId, proofId, sibling, branchOrder,
        status, getExecutableId, None, None,
        getLocalProvableId, userExe, ruleName,
        if (local != null) local.subgoals.size else -1,
        if (local != null) local.subgoals.size else -1)
    }
  }

  var youngestSibling: Option[Int] = initialSibling
  var node: TraceNode = null
  var isDead: Boolean = false
  var nodesWritten: List[TraceNode] = Nil

  /* Debug info: Records how deep inside the tree of begin-end pairs we are */
  var depth: Int = 0

  def begin(v: BelleValue, expr: BelleExpr): Unit = {
    synchronized {
      depth = depth + 1
      if (isDead) return
      val parent = node
      node = new TraceNode(isFirstNode = parent == null)
      node.parent = parent
      node.sibling = youngestSibling
      node.executable = expr
      node.status = ExecutionStepStatus.Running

      if (parent != null) {
        parent.status = ExecutionStepStatus.DependsOnChildren
        parent.reverseChildren = node :: parent.reverseChildren
      }
      if (parent == null) {
        node.stepId = Some(db.addExecutionStep(node.asPOJO))
        nodesWritten = node :: nodesWritten
      }
    }
  }

  def end(v: BelleValue, expr: BelleExpr, result: Either[BelleValue, BelleThrowable]): Unit = {
    synchronized {
      depth = depth - 1
      if (isDead) return
      val current = node
      node = node.parent
      youngestSibling = current.id
      current.status =
        result match {
          case Left(_) => ExecutionStepStatus.Finished
          case Right(_) => ExecutionStepStatus.Error
        }
      if (node != null) return
      //      db.updateExecutionStep(current.stepId.get, current.asPOJO)
      //      if (node == null) {
      //        result match {
      //          // Only reconstruct provables for the top-level because the meaning of "branch" can change inside a
      // tactic
      //          case Left(BelleProvable(p, _)) =>
      //            current.output = globalProvable(p, branch)
      //            current.local = p
      //          case _ =>
      //        }
      //        if (current.output != null) {
      //          db.updateExecutionStep(current.stepId.get, current.asPOJO)
      //          if (current.output.isProved) {
      //            val p = db.getProofInfo(proofId)
      //            val provedProof = new ProofPOJO(p.proofId, p.modelId, p.name, p.description, p.date, p.stepCount,
      //              closed = true, p.provableId, p.temporary)
      //            db.updateProofInfo(provedProof)
      //          }
      //        }
      //      }
      if (node == null) {
        result match {
          // Only reconstruct provables for the top-level because the meaning of "branch" can change inside a tactic
          case Left(BelleProvable(p, _)) =>
            // no longer want to construct global provables (want to allow halfway done substitutions)
            current.local = p
            db.updateExecutionStep(current.stepId.get, current.asPOJO)
            if (db.getPlainOpenSteps(proofId).isEmpty) {
              //@note proof might be done
              val p = db.getProofInfo(proofId)
              val provedProof = new ProofPOJO(p.proofId, p.modelId, p.name, p.description, p.date, p.stepCount,
                closed = true, p.provableId, p.temporary, p.tactic)
              db.updateProofInfo(provedProof)
            }
          case _ =>
            db.updateExecutionStep(current.stepId.get, current.asPOJO)
        }
      }
    }
  }

  /** Called by HyDRA before killing the interpreter's thread. Updates the database to reflect that the computation
    * was interrupted. There are two race conditions to worry about here:
    * (1) kill() can race with a call to begin/end that was in progress when kill() started. This is resolved with
    * a mutex (synchronized{} blocks)
    * (2) An in-progress computation can race with a kill signal (sent externally after kill() is called). This is
    * resolved by setting a flag during kill() which turns future operations into a no-op. */
  def kill(): Unit = {
    synchronized {
      isDead = true
      nodesWritten.foreach(node =>
        node.stepId.foreach { id =>
          node.status = ExecutionStepStatus.Aborted
          db.updateExecutionStep(id, node.asPOJO)
        })
    }
  }
}

case class StepPointer(step: Int, branch: Int) {}

class StepByStepRecordingListener(db: DBAbstraction,
                                  proofId: Int,
                                  previousStep: Option[StepPointer],
                                  ruleName: String,
                                 ) extends IOListener {
  /** Set when we've finished the entire proof tree */
  var isDone: Boolean = false
  /** Set when the listener is killed */
  var isDead: Boolean = false

  /** Our depth within an atomic leaf node */
  var depth: Int = 0
  /** The node that is currently being executed */
  var node: Option[StepNode] = None

  /** A list of all of the nodes that have been added to the DB. Used for aborting nodes if `kill`ed */
  var allNodes: List[StepNode] = Nil

  abstract class StepNode(previous: List[StepPointer], val parent: Option[StepNode], val executable: BelleExpr) {
    var status: ExecutionStepStatus = ExecutionStepStatus.Running

    /** If this node failed, was it recorded into the db */
    var failureRecorded = false

    protected var _local: ProvableSig = _

    def local_=(local: ProvableSig): Unit = {
      assert(_local == null)
      _local = local
    }

    def local: ProvableSig = _local

    /** Where should succeeding nodes attach to this provable */
    def next: List[StepPointer]

    def localNumSubgoals: Int = if (local != null) local.subgoals.size else -1

    def localNumOpenSubgoals: Int = if (local != null) local.subgoals.size else -1

    /** Add this node to the database */
    def add(): Unit = ()

    /** Update this node in the database */
    def update(): Unit = ()

    /** Remove this node and all of its descendants from the database */
    def remove(): Unit = ()

    /** Starts a new child of this node running `executable` on `input`
      *
      * @return Some(child) unless this node is an atom that cannot have children
      */
    def startChild(input: BelleValue, executable: BelleExpr): Option[StepNode]

    /** Notifies that the currently running `child` of this node finished */
    def finishChild(child: StepNode): Unit
  }

  /** A single atomic step that is inserted into the databse */
  class AtomicStepNode(source: Option[StepPointer], parent: Option[StepNode], executable: BelleExpr)
    extends StepNode(previous = source.toList, parent, executable) {

    var id: Option[Int] = None

    lazy val executableId: Int = db.addBelleExpr(executable)

    val previousId: Option[Int] = source.map(_.step)
    val branchOrder: Int = source.map(_.branch).getOrElse(0)

    protected def asPOJO: ExecutionStepPOJO =
      ExecutionStepPOJO(id, proofId, previousId, branchOrder, status, executableId, None, None, localProvableId,
        userExecuted = parent == null, ruleName, localNumSubgoals, localNumOpenSubgoals)

    private var _localProvableId: Option[Int] = None

    def localProvableId: Option[Int] = {
      if (_local != null && _localProvableId.isEmpty)
        _localProvableId = Some(db.createProvable(_local))
      _localProvableId
    }

    override def next: List[StepPointer] =
      if (local == null)
        source.toList
      else
        id match {
          case Some(step) =>
            local.subgoals.indices.map(StepPointer(step, _)).toList
          case _ =>
            Nil
        }

    override def add(): Unit = {
      assert(id.isEmpty)
      id = Some(db.addExecutionStep(asPOJO))
      allNodes = this :: allNodes
    }

    override def update(): Unit = {
      id.foreach(db.updateExecutionStep(_, asPOJO))
    }

    override def remove(): Unit = {
      id.foreach(db.deleteExecutionStep(proofId, _))
      id = None
    }

    def startChild(input: BelleValue, executable: BelleExpr): Option[StepNode] =
      None

    def finishChild(child: StepNode): Unit =
      throw new AssertionError("Cannot finish a child on atomic node")
  }

  /**
    * Abstract class describing nodes whose children should be linked together sequentially. You can think of this
    * loosely as a path down the derivation tree if you ignore multiple tips
    */
  class SequentialStepNode(previous: List[StepPointer], parent: Option[StepNode], executable: BelleExpr)
    extends StepNode(previous, parent, executable) {

    protected var currentTip: List[StepPointer] = previous
    protected var childrenFinished: Int = 0
    protected var children: List[StepNode] = Nil

    override def startChild(input: BelleValue, executable: BelleExpr): Option[StepNode] = {
      val child = makeNode(input, executable, Some(this), currentTip)
      children = child :: children
      Some(child)
    }

    override def finishChild(child: StepNode): Unit = {
      currentTip = child.next
      childrenFinished += 1
    }

    override def remove(): Unit = {
      children.foreach(_.remove())
    }

    override def next: List[StepPointer] = currentTip
  }

  class SeqStepNode(previous: List[StepPointer], parent: Option[StepNode], executable: SeqTactic)
    extends SequentialStepNode(previous, parent, executable) {

    override def finishChild(child: StepNode): Unit = {
      super.finishChild(child)

      if (child.status != ExecutionStepStatus.Finished) {
        if (childrenFinished > 1) {
          // Failing on the second branch
          failureRecorded = true
          if (!child.failureRecorded)
            currentTip = addPendingNode(executable.right, this, currentTip).next
        } else if (child.failureRecorded) {
          failureRecorded = true
          // Failing on the first branch
          // Record a second pending tactic on top of the first
          currentTip = addPendingNode(executable.right, this, currentTip).next
        }
      }
    }
  }

  class SaturateStepNode(previous: List[StepPointer], parent: Option[StepNode], executable: SaturateTactic)
    extends SequentialStepNode(previous, parent, executable) {

    override def finishChild(child: StepNode): Unit = {
      if (child.status != ExecutionStepStatus.Finished) {
        // If we didn't succeed, delete this child as if nothing happened
        child.remove()
        children = children.tail
      } else {
        super.finishChild(child)
      }
    }
  }

  class RepeatStepNode(previous: List[StepPointer], parent: Option[StepNode], executable: RepeatTactic)
    extends SequentialStepNode(previous, parent, executable) {

    override def finishChild(child: StepNode): Unit = {
      super.finishChild(child)

      if (child.status != ExecutionStepStatus.Finished) {
        failureRecorded = true
        val times = executable.times - childrenFinished + (if (child.failureRecorded) 0 else 1)
        if (times > 0) {
          currentTip = addPendingNode(RepeatTactic(executable.child, times), this, currentTip).next
        }
      }
    }
  }

  class OnAllNode(previous: List[StepPointer], parent: Option[StepNode], executable: OnAll)
    extends SequentialStepNode(previous, parent, executable) {

    override def finishChild(child: StepNode): Unit = {
      super.finishChild(child)
      if (child.failureRecorded)
        this.failureRecorded = true
    }
  }

  class BranchStepNode(previous: List[StepPointer], parent: Option[StepNode], executable: BelleExpr)
    extends StepNode(previous, parent, executable) {

    var stepsLeft: List[StepPointer] = previous
    var allStepsRev: List[StepPointer] = Nil

    override def startChild(input: BelleValue, executable: BelleExpr): Option[StepNode] = {
      stepsLeft match {
        case Nil =>
          throw new AssertionError("Unexpectedly had no steps left. Listener got out of sync with the interpreter")
        case hd :: _ =>
          Some(makeNode(input, executable, Some(this), hd :: Nil))
      }
    }

    override def finishChild(child: StepNode): Unit = {
      if (child.status != ExecutionStepStatus.Finished && !child.failureRecorded) {
        //@todo Record failures and successes to wrap entire branch if all children fail
        failureRecorded = true
        val node = addPendingNode(child.executable, this, child.next)
        allStepsRev = node.next.reverse ++ allStepsRev
      } else {
        allStepsRev = child.next.reverse ++ allStepsRev
      }
      stepsLeft = stepsLeft.tail
    }

    override def next: List[StepPointer] = allStepsRev.reverse
  }

  //@todo Add nodes for EitherTactic and DependentTactics

  private def makeNode(input: BelleValue, executable: BelleExpr,
                       parent: Option[StepNode], previous: List[StepPointer]
                      ): StepNode = {
    executable match {
      case seq@SeqTactic(_, _) =>
        new SeqStepNode(previous, parent, seq)
      case rep@RepeatTactic(_, _) =>
        new RepeatStepNode(previous, parent, rep)
      case sat@SaturateTactic(_) =>
        new SaturateStepNode(previous, parent, sat)
      case onall@OnAll(_) =>
        new OnAllNode(previous, parent, onall)
      case BranchTactic(_) =>
        new BranchStepNode(previous, parent, executable)
      case _ =>
        //@note Atomic nodes can only have one predecessor
        assert(previous.drop(1).isEmpty)
        new AtomicStepNode(previous.headOption, parent, executable)
    }
  }

  private def addPendingNode(executable: BelleExpr, parent: StepNode, previous: List[StepPointer])
  : StepNode = {
    val target = previous.last
    val provable = db.getExecutionStep(proofId, target.step).get.local.sub(target.branch)
    val notes = if (previous.length > 1) Some("Outside branch") else None
    val node = new AtomicStepNode(Some(target), Some(parent), PendingTactic(notes, executable))

    node.status = ExecutionStepStatus.Finished
    node.local = provable
    node.add()
    node.update() //@note For some reason the addExecutionStep doesn't propagate the subgoals counts
    node
  }

  override def begin(input: BelleValue, expr: BelleExpr): Unit = this.synchronized {
    assert(!isDone)
    if (isDead) return

    if (depth > 0) {
      depth += 1
      return
    }

    node match {
      case None =>
        val next = makeNode(input, expr, node, previousStep.toList)
        next.add()
        node = Some(next)

      case Some(n) =>
        n.startChild(input, expr) match {
          case None =>
            depth += 1
          case Some(next) =>
            n.status = ExecutionStepStatus.DependsOnChildren
            n.update()

            next.add()
            node = Some(next)
        }
    }
  }

  override def end(input: BelleValue, expr: BelleExpr, output: Either[BelleValue, BelleThrowable]
                  ): Unit = this.synchronized {
    assert(!isDone)
    if (isDead) return

    if (depth > 0) {
      depth -= 1
      return
    }

    val curr = node.get
    output match {
      case Left(BelleProvable(p, _)) =>
        curr.local = p
        curr.status = ExecutionStepStatus.Finished
      case Left(_) =>
        curr.status = ExecutionStepStatus.Finished
      case Right(_) =>
        curr.status = ExecutionStepStatus.Error
    }
    curr.update()

    curr.parent match {
      case None =>
        if (db.getPlainOpenSteps(proofId).isEmpty)
          db.updateProofSetClosed(proofId)
        isDone = true

      case Some(parent) =>
        parent.finishChild(curr)
        node = Some(parent)
    }
  }

  override def kill(): Unit = this.synchronized {
    isDead = true
    allNodes.foreach(node => {
      node.status match {
        case ExecutionStepStatus.DependsOnChildren | ExecutionStepStatus.Running =>
          node.status = ExecutionStepStatus.Aborted
          node.update()
      }
    })
  }
}